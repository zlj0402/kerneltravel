/*
 * @output:
zlj@zlj-vm:~/zljgit/algorithm/C++/06_Union_Find/Union_Find$ ./main
UF3, 20000000 ops, 8.5044 s
UF4, 20000000 ops, 8.78401 s
UF5, 20000000 ops, 6.43364 s
UF6, 20000000 ops, 6.91759 s
 */

/*
 * @brief: 
 * 	+ UF6: 每层层数最低的递归路径压缩; 
 * 		+ 主要消耗在递归堆栈上，不然理论上快 UF5（路径压缩，find时将子树，接到"爷爷"树下面^^）
 * 	+ UF5: 路径压缩方式1; 介绍就如上一行所示;
 *
 *  + UF5 和 UF6 是基于 rank 的基础上;
 *
 * 	+ UF4: 基于 rank 的优化，将层数少的子树，接到层数多的子树下面;
 * 	+ UF3: 基于 size 的优化，将子树元素少的子树，将子树接到元素多的子树下;
 *
 * @summary:
 * 		+ 个人更喜欢，基于 rank 的优化，逻辑目的更清晰;
 * 		+ 路径压缩，更喜欢递归的方式;
 * 			+ 所有节点都在根节点下方;
 * 			+ 效率随机，不如就递归;
 */
